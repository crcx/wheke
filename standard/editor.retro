
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( This is a block editor that I've been using for many years. )
( It's simple, and doesn't have a lot of features, but it is  )
( more than enough for most of my prototyping work.           )
(                                                             )
( Actually, it's proven more popular than I ever expected. It )
( has been used by many of Retro's users, and implementations )
( now exist for several other Forth systems.                  )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Line and column numbers start at 0.                         )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Quick Reference:                                            )
(      # s        Select a new block                          )
(        p        Previous block                              )
(        n        Next block                                  )
(      # i ..     Insert .. into line                         )
(   # #2 ia ..    Insert .. into line [#2] starting at        )
(                 column [#]                                  )
(        x        Erase the current block                     )
(      # d        Erase the specified line                    )
(        v        Display the current block                   )
(        e        Evaluate Block                              )
(        new      Erase all blocks                            )
( # red.set#      Set the # of blocks. Calls 'new'            )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( The memory layout and basic configuration.                  )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
variable #-blocks
512 constant #-block-size
variable offset

10 variable: line-ending

variable blk
: block     512 * offset @ + ;
: (block)   blk @ block ;
: (line)    64 * (block) + ;

: (v) ;
: (e) ;
: v   ( -  ) (v) ;
: s   ( n- ) blk ! v ;
: d   ( n- ) (line) 32 64 fill v ;
: x   ( -  ) (block) 32 512 fill v ;
: p   ( -  ) -1 blk +! v ;
: n   ( -  ) 1 blk +! v ;
: ia  ( nn"- )
  whitespace @ push whitespace off
  (line) + push line-ending @ accept tib pop
  tib getLength copy v
  pop whitespace ! ;
: i   ( n"- ) 0 swap ia v ;
: new ( -  ) offset @ 32 #-block-size #-blocks @ * fill ;
: e   ( -  ) (e) ;


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Default Block Viewer                                        )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{
  : (type)  for dup @ emit 1+ next ;
  : type    (type) drop ;
  : space   32 emit ;

  : row     . dup 64 type 64 + cr ;
  : .rows   0 row 1 row 2 row 3 row
            4 row 5 row 6 row 7 row ;
  : .block  ." Block: " blk @ . ." of " #-blocks @ . ;
  : x       ." +---:---+---:---" ;
  : bar     space space x x x x cr ;
  : vb      bar blk @ block .rows drop bar ;
  : status  .block ;
  here is (v) ] clear vb status ;
}


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( Default Block Evaluator                                     )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
{
  variable count
  variable buffer
  : setup  ( -- )    512 count ! (block) buffer ! ;
  : -remap ( -- )    ['] key :devector ;
  : get    ( -- c )  buffer @ @ ;
  : next   ( -- c )
    count @ 0 =if 32 -remap ;then
    count -- get buffer ++ ;
  : remap  ( -- )    ['] next ['] key :is ;
  here is (e) ] setup remap ;
}

: red.set#
  #-blocks ! #mem @ #-block-size #-blocks @ * - offset ! new ;


( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
( All done! Fill the blocks with spaces, and we're good to go )
( ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ )
64 red.set#
